variables:
  MAJOR_BRANCH: master

stages:
  #  - sync
  - test
  - build
  - push
  - deploy

default:
  tags:
    - placeholder_ftp

before_script:
  - echo "Hello, $GITLAB_USER_LOGIN!"
  - echo "CI_REGISTRY_IMAGE:$CI_REGISTRY_IMAGE"
  - echo "CI_COMMIT_SHORT_SHA:$CI_COMMIT_SHORT_SHA"

#update-readme-job:
#  stage: sync
#  script:
#  - "curl -X POST --fail -F token=3ddf785cc6a89f02d452ea79ab976a -F ref=REF_NAME http://gitlab.cloud.gcm/api/v4/projects/709/trigger/pipeline"

build-job:
  stage: build
  rules:
    - *readme-no-commit
    - *master-commit
  script:
    - echo "Building Dockerfile..."
    # fetches the latest image (not failing if image is not found)
    - docker pull $CI_REGISTRY_IMAGE:latest || true
    - docker build --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    - echo "Building complete."

push-latest:
  stage: push
  rules:
    - *readme-no-commit
    - *master-commit
  script:
    # поскольку у нас нет гарантии, что это задание будет выполнено тем же пользователем, который
    # создавал изображение на предыдущем шаге, мы повторно загружаем его локально
    - *docker-login
    - docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    # Then we tag it "latest"
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:latest

deploy-prod:
  stage: deploy
  rules:
    - *readme-no-commit
    - *master-commit
  script:
    - "curl -X POST --fail -F token=$GET_REGISTRIE_TOKEN -F ref=master http://gitlab.cloud.gcm/api/v4/projects/698/trigger/pipeline"
  environment: production
